/*

rootToken takes a merkle root of a collection of records address + uint256 and issues tokens equal to the unint value to the address when a proof is provided. 

Contract could be easily extended to include other kinds of records.

Example root: 0xb93a9acf41a4bc9f8d129b3b30952dc1a36f99be1de3beccfe8f0b9f7f3c428b

associated proof 1:
["0x40e946e467d4c8af595dad6d4dc4e0097bd0849e1b8e0d452d476eed2fc8672b","0xa2f9e27c679c6350d2b18e8fe05bae629435fa55b95e131390e4606db1346205","0x0d6c47d0cfeeef0317799717216300b28aac1be3afc235fa61264ce4d2fd0758","0xbb4134dfa3e7281239510ad2e2fa4ab8927ef0d807453f89cce66264987860ab","0x2ca297bc1d15d41cd5d929752c6230d6cb4284d035149e965412c2d2508521c1","0x8e704f403e74fb864c0984c7163cbe1df70a09d1850f13759621663061fba765","0xd92b9df86f287844602e49e01d2a9fe023e84d8bb5bad2fcdb238b77eb5d991e","0x5ed801a1efff8d2ead19e8e78f3b65297de8f936d71c4644d55a262e71f3c93f","0x352650bd44caaba2f7ab5d85a5524bd48059290a956b416aa712de62ea8d80b2"],[1,1,0,1,0,1,1,1,1],"0x0407d658E5a4e7eb6C49Db1b899dCeb7bd8c091A",100000000

associated proof 2:
["0x061b48c285ce36fdb1a13981ecfdc62460abd69610406b31b675417876e14e21","0xa2f9e27c679c6350d2b18e8fe05bae629435fa55b95e131390e4606db1346205","0x0d6c47d0cfeeef0317799717216300b28aac1be3afc235fa61264ce4d2fd0758","0xbb4134dfa3e7281239510ad2e2fa4ab8927ef0d807453f89cce66264987860ab","0x2ca297bc1d15d41cd5d929752c6230d6cb4284d035149e965412c2d2508521c1","0x8e704f403e74fb864c0984c7163cbe1df70a09d1850f13759621663061fba765","0xd92b9df86f287844602e49e01d2a9fe023e84d8bb5bad2fcdb238b77eb5d991e","0x5ed801a1efff8d2ead19e8e78f3b65297de8f936d71c4644d55a262e71f3c93f","0x352650bd44caaba2f7ab5d85a5524bd48059290a956b416aa712de62ea8d80b2"],[0,1,0,1,0,1,1,1,1],"0x0407d658E5a4e7eb6C49Db1b899dCeb7bd8c091A",123456789

Example generated by https://gist.github.com/JonnyLatte/5d72bec5bc708a0be61b3d3b15eadbb3

which generates 100K records, generating the markle tree and allowing a path to the merkle root to be found on each record 

*/

pragma solidity ^0.4.12;

import "github.com/JonnyLatte/MiscSolidity/appToken.sol";

contract rootBase  {

    mapping(bytes32 => bool) public roothashes;
    mapping(bytes32 => bool) public used;
    
    event onRootHash(bytes32 hash, bool valid);
    
    function setRoot(bytes32 hash, bool valid) internal {
        roothashes[hash] = valid;
        onRootHash(hash,valid);
    }

    function prove(bytes32[] hashes, bool[] parity, bytes32 subject) constant public returns(bool valid)  {
        bytes32 h = subject; 
        for(uint i = 0; i < hashes.length; i++) {
            if(parity[i]) h = keccak256(h        ,hashes[i]);
            else          h = keccak256(hashes[i],h        );
        }
        return (roothashes[h] && used[subject] == false);
    }
}

contract rootToken is rootBase, appToken 
{
    function rootToken(bytes32 _roothash) public 
    {
        setRoot(_roothash,true);
    }

    function processClaim(bytes32[] hashes, bool[] parity, address target, uint256 value) public returns (bool ok)
    {
        var subject = keccak256(target, value);
        
        if(prove(hashes,parity,subject)) {
            used[subject] = true;
            issueTokens(target, value);
            return true;
        }
    }
    
   
    function checkProcessClaim(bytes32[] hashes, bool[] parity, address target, uint256 value) public constant returns (bool ok)
    {
        var subject = keccak256(target, value);
        
        if(prove(hashes,parity,subject)) {
           // used[subject] = true;
            //issueTokens(target, value);
            return true;
        }
    }
}
